!function(){"undefined"==typeof module?this.LispMarkup=r():module.exports=r();var P=function(r,e){if(null==e)return r;return e};function x(r){throw console.error.apply(null,arguments),new Error(r)}function r(){var t={};function d(){return arguments[arguments.length-1]}var n=s(e);t.htmlTagHandler=e,t.lispTree=i,t.customTagMarkupConverter=s,t.toHtml=function(r,e){{if("string"==typeof r)return n(i(r),e);if(Array.isArray(r))return n(r,e)}},t.compileTemplate=function(e,r){"string"==typeof e&&(e=i(e));Array.isArray(e)||x("LispMarkup.compileTemplate: Template must be a lisp tree or an array.",e);var t;t=r?s(r):n;return function(r){return t(e,r)}},t.addMacro=a,t.addFunction=function(r,e){a(r,(i=e,function(r,e,t){for(var n=[],a=1;a<r.length;++a)n.push(t(r[a],e));return i.apply(null,n)}));var i},t.hasMacro=function(r){return M.hasOwnProperty(r)};var M=function(){var r={};r.WITH=function(r,e,t){var n=[];r.length<3&&x("LispMarkup.macros._with not enough list arguments");var a=r[1];null!==e&&"undefined"!==e||x("LispMarkup.macros._with data is not defined");"function"==typeof a?e=a(e):"string"==typeof a||"number"==typeof a?e=e[a]:x("LispMarkup.macros._with invalid type for context argument");for(var i=2;i<r.length;++i)n.push(t(r[i],e,t));return n.join("")},r.COMMENT=n,r.CONCAT=i,r.CONCAT_SPACE=s,r.IF=t,r.GET=o,r.CSS=function(r,u,p){for(var e=["<style>"],t=1;t<r.length;++t)e.push(s(r[t]));return e.push("</style>"),e.join("");function l(r){var e=[];if("function"==typeof r)"string"!=typeof(r=r(u))&&x("LispMarkup.macros.css: tranform function for css rule did not return a string value."),e.push(r);else if("string"==typeof r)e.push(r);else if(Array.isArray(r)){var t=r[0];if("function"==typeof t)return l(t(r,u,p));if("string"==typeof t){r.length<2&&x("LispMarkup.macros.css: css rule must have at least 2 entries, a property and a value");for(var n=t,a=[],i=1;i<r.length;++i){var s=r[i];if(Array.isArray(s)){"function"!=typeof s[0]&&x("LispMarkup.macros.css: if css rule value is a list, it must be a macro call.");var o=s[0](s,u,p);a.push(o)}else"function"==typeof s?a.push(s(u)):"string"==typeof s?a.push(s):x("LispMarkup.macros.css: css rule value not a string, macro call, or view returning a string.")}e.push(n+": "+a.join(" ")+"; ")}else x("LispMarkup.macros.css: css rule property not a string")}return e.join("")}function s(r){var e=[];if("string"==typeof r)e.push(r);else if("function"==typeof r)"string"!=typeof(r=r(u))&&x("LispMarkup.macros.css: css entry view did not return a string"),e.push(r);else if(Array.isArray(r)){var t=r[0];if("function"==typeof t)return s(t(r,u,p));if("string"==typeof t){var n=t;e.push(n+"{");for(var a=1;a<r.length;++a){var i=r[a];e.push(l(i))}e.push("}")}else x("LispMarkup.macros.css: invalid selector type")}else x("LispMarkup.macros.css: invalid entry type");return e.join("")}},r.LET=a,r.FOR=function(r,e,t){r.length<4&&x("LispMarkup.macros.FOR: at least 3 arguments required.");var n=r[1],a=r[2],i=null,s=null;if(Array.isArray(n))if(0==n.length);else if(n.length<3){var o=2==n.length?n[0]:null,u=n[n.length-1];null!=o&&null!=o&&("string"!=typeof o&&x("LispMarkup.macros.FOR: reference variable declaration not a string.",o),"$"!=o[0]&&x("LispMarkup.macros.FOR: reference variable should begin with '$'",o)),null!=u&&null!=u||x("LispMarkup.macros.FOR: value variable unexpectedly null or undefined."),"string"!=typeof u&&x("LispMarkup.macros.FOR: value variable declaration not a string.",o),"$"!=u[0]&&x("LispMarkup.macros.FOR: reference variable should begin with '$'",o),u.match(B)||x("LispMarkup.macros.FOR: variable name not valid",u),i=o.substring(1),s=u.substring(1)}else x("LispMarkup.macros.FOR: variable_argument list may not have more than 2 entries",n,r);else"string"==typeof n?(0==n.length&&x("LispMarkup.macros.FOR: variable_argument unexpectedly an empty string."),"$"!=n[0]&&x("LispMarkup.macros.FOR: variable_argument was a string, must be a '$' prefixed variable name"),n.match(B)||x("LispMarkup.macros.FOR: variable name not valid",n),s=n.substring(1)):x("LispMarkup.macros.FOR: variable_argument must be a list or a string.",n);var p=!1,l=1,f=1,c=1,g=null;if(Array.isArray(a)){var m=a;if(0==m.length);else if(1==m.length){var h=m[0];$(h)||x("LispMarkup.macros.FOR: single range argument must be an integer.",h,a),p=!0;var v=parseInt(h);l=0<v?1:-1,f=v}else if(2==m.length){var y=m[0],d=m[1];(isNaN(y)||isNaN(d))&&x("LispMarkup.macros.FOR: range start or end not a number."),p=!0,l=parseFloat(y),f=parseFloat(d)}else if(3==m.length){var y=m[0],d=m[1],M=m[2];(isNaN(y)||isNaN(d)||isNaN(M))&&x("LispMarkup.macros.FOR: range start or end not a number."),p=!0,l=parseFloat(y),f=parseFloat(d),c=parseFloat(M)}else x("LispMarkup.macros.FOR: range argument may only have 3 entries.")}else"string"==typeof a?S.test(a)?(p=!0,l=1,f=parseInt(a)):a.match(C)?x("LispMarkup.macros.FOR: single value range argument may not be non-integer number.",a):g=a:"number"==typeof a&&($(a)||x("LispMarkup.macros.FOR: single value range argument may not be non-integer number.",a),p=!0,l=1,f=Math.round(a));var b=r.slice(3),k=[],L={},w=[],A=null;null!==i&&(L[i]="");null!==s&&(L[s]="");if(p){0==c&&x("LispMarkup.macros.FOR: 0 increment not allowed",r),f<l&&0<c&&(c=-c),l<f&&c<0&&(c=-c);for(var T=l;0<c?T<=f:f<=T;T+=c){var v=parseFloat(T.toFixed(12));w.push([v,v])}}else if(A=P({},g?e?e[g]:null:e),Array.isArray(A))for(var T=0;T<A.length;++T)w.push([T+1,A[T]]);else if("object"==typeof A)for(var O in A)w.push([O,A[O]]);for(var T=0;T<w.length;++T){var F=w[T][0],R=w[T][1],E=e;null!==i&&(L[i]=F),null!==R&&(null!==s?L[s]=R:E=R);for(var j=null!==i||null!==s?_(b,L):b,N=0;N<j.length;++N)k.push(t(j[N],E))}return k.join("")},r.STRINGIFY=function(r,e,t){if(1==r.length)return JSON.stringify(e);if(2==r.length)return JSON.stringify(e[r[1]]);x("LispMarkup.macros.STRINGIFY: only 0 or 1 arguments allowed.")},r.PROPERTIES=e,r.PROPS=e,r["?"]=t,r["@"]=o,r[".."]=i,r["..."]=s,r["##"]=n,r[":"]=e,r["="]=a;var S=/^(0|[-]?[1-9][0-9]*)$/,C=/^(0|[-]?[1-9][0-9]*)(\.[0-9]+){0,1}$/,B=/^\$[_a-zA-Z0-9]+$/;return r;function e(r,e,t){for(var n={},a=1;a<r.length-1;a+=2)n[r[a]]=r[a+1];return n}function t(r,e,t){r.length<4&&x("LispMarkup.macros._if not enough list arguments");var n=r[1],a=!1;return"function"==typeof n?a=n(e):"string"==typeof n||"number"==typeof n?a=!!e&&e[n]:"boolean"==typeof n?a=n:isNaN(n)?x("LispMarkup.macros._if invalid type for context argument"):a=0!=n,t(a?r[2]:r[3],e,t)}function n(r,e,t){return""}function $(r){if("string"==typeof r)return r.match(S);if("number"!=typeof r)return!1;var e=r-Math.round(r);return!(1e-6<e||-e<-1e-6)}function a(r,e,t){var n,a=r[1],i={};r.length<3&&x("LispMarkup.macros.LET: At least 2 arguments are required"),(n=Array.isArray(a)?a:[r[1],r[2]]).length%2!=0&&x("LispMarkup.macros.LET: assignment list must be even length.");for(var s=0;s<n.length;s+=2){var o=n[s],u=n[s+1];Array.isArray(u)&&(u=t(u,e)),"function"==typeof o&&(u=u(e)),"string"==typeof o&&"string"==typeof u||x("LispMarkup.macros.LET: variable name was not a string."),"string"==typeof o&&"string"==typeof u||x("LispMarkup.macros.LET: variable value not a string or convertible to string"),"$"!=o.charAt(0)&&x("LispMarkup.macros.LET: variable must begin with '$'"),i.hasOwnProperty(o)&&x("LispMarkup.macros.LET: variable '"+o+"' assigned previously in this let statement."),i[o.substring(1)]=u}for(var r=_(r.slice(Array.isArray(a)?2:3),i),p=[],s=0;s<r.length;++s)p.push(t(r[s],e).toString());return p.join("")}function _(r,e){if("object"!=typeof e&&x("LispMarkup.substitute: vars must be an object map"),Array.isArray(r)){for(var t=[],n=0;n<r.length;++n)t[n]=_(r[n],e);return t}if("object"==typeof r){var t={};for(var a in r)t[a]=_(r[a],e);return r}if("string"==typeof r){for(var i=[],n=0,a=0;n<r.length;++n){var s=r[n];if("\\"==s&&++n,"'"==s)for(;++n<r.length&&"'"!=r[n];)"\\"==r[n]&&++n;if("$"==s){var o=n+1,u="";if(++n<r.length&&"{"==r[n]){for(;++n<r.length&&"}"!=r[n];);u=r.substring(o+1,n),++n,console.log(u)}else{for(;n<r.length&&r[n].match(/[_0-9A-Za-z]/);)++n;u=r.substring(o,n)}u.length&&e.hasOwnProperty(u)&&(i.push(r.substring(a,o-1),e[u]),a=n)}}return i.push(r.substring(a)),i.join("")}return r}function i(r,e,t){for(var n=[""],a=1;a<r.length;++a){var i=t(r[a],e);n.push(i.toString().trim())}return n.join("")}function s(r,e,t){for(var n=[""],a=1;a<r.length;++a){var i=t(r[a],e);n.push(i.toString())}return n.join("")}function o(r,e,t){if(1==r.length)return e.toString();if(2==r.length)return e[r[1]]?e[r[1]].toString():"";if(3==r.length){var n=e[r[1]];return null==n&&(n=t(r[2],e,t)),n.toString()}x("LispMarkup.macros.get invalid number of list arguments")}}();for(var r in t.macros={},M)t.macros[r]=M[r];return t;function a(r,e){M.hasOwnProperty(r)&&x("LispMarkup.addMacro: macro '"+r+"' already exists."),M[r]=e,t.macros[r]=e}function e(e,t){d(e,""),d(t,{},void 0),t||(t={});var r=["<"],n=0,a=0,i=[],s="",o="tag";function u(){var r=e.substr(n,a-n);"tag"==o&&(s=r),"id"==o&&(t.id=r),"class"==o&&i.push(r),n=a+1}for(;a<e.length;++a){var p=e[a];"#"==p&&(u(),o="id"),"."==p&&(u(),o="class")}n<a&&u(),0==s.length&&(s="div"),r.push(s);var l=[];for(var f in t)l.push(f,t[f]);for(n=0;n<l.length-1;n+=2){var c=l[n],g=l[n+1];null==g?r.push(" ",c):r.push(" ",c,'="',g,'"')}if(i.length){r.push(' class="');for(n=0;n<i.length;++n)r.push(" "+i[n]);r.push('"')}return r.push(">"),[r.join(""),"</"+s+">"]}function i(r){for(var e,t=[],n=t,a=0,i=0;a<r.length;++a){var s=r[a];if("\\"!=s){if("'"==s){for(var o=a==i;"'"!=r[++a];)a==r.length&&x("lispTree: unterminated string","token, node, root, s:",r.substring(i,a),n,t,r),"\\"==r[a]&&++a;o&&(a==r.length-1||r[a+1].match(/[\s()]/))&&(n.push(r.substring(i+1,a)),i=a+1)}if('"'==s){for(o=a==i;'"'!=r[++a];)a==r.length&&x("lispTree: unterminated string","token, node, root, s:",r.substring(i,a),n,t,r),"\\"==r[a]&&++a;o&&(a==r.length-1||r[a+1].match(/[\s()]/))&&(n.push(r.substring(i+1,a)),i=a+1)}if("("==s&&(i<a&&n.push(r.substring(i,a)),n.push(e=[]),e.parent=n,n=e,i=a+1),")"==s&&(i<a&&n.push(r.substring(i,a)),n==t&&x("lispTree: xtra ')'","token, node, root, s:",r.substring(i,a),n,t,r),n=n.parent,i=a+1),s.match(/\s/)){for(i<a&&n.push(r.substring(i,a));a<r.length&&r[a].match(/\s/);)++a;i=a,--a}}else a==r.length-1&&x("lispTree: '\\' is last character","token, node, root, s:",r.substring(i,a),n,t,r),r=r.substring(0,a)+r.substring(a+1)}return n!=t&&x("lispTree: xtra '('","token, node, root, s:",r.substring(i,a),n,t,r),i<a&&t.push(r.substring(i,a)),t}function s(y){return"function"!=typeof y&&x("LispMarkup markup conversion function: taghandler argument must be a function"),function r(e,t){d([],"",0,e);t=d({},[],P({},t));var n={};var a=e[0];var i=null;var s=[""];if(null==e)return"";if("string"==typeof e||"number"==typeof e)return e.toString()+" ";"string"==typeof a&&(M.hasOwnProperty(a)?a=M[a]:i=a);if("function"==typeof a){var o=a,u=o(e,t,r);return"string"==typeof u?u:Array.isArray(u)?r(u,t):"object"==typeof u&&u.constructor=={}.constructor?u:u?u.toString():""}for(var p=0;p<e.length;++p)if(0!=p||!i){var l=e[p];if(Array.isArray(l)){var f=r(l,t);if("object"==typeof f&&f.constructor=={}.constructor)for(var c in f){var g=f[c];Array.isArray(g)?n[c]=r(g,t):"string"==typeof g||"number"==typeof g?n[c]=g:null==g?n[c]=null:x("LispMarkup: illegal property value type.")}else s.push(f)}else if("object"==typeof l)for(var c in l){var g=l[c];if(Array.isArray(g))n[c]=r(g,t);else if("string"==typeof g||"number"==typeof g)n[c]=g;else if(null==g)n[c]=null;else if("function"==typeof g){var m=g,h=m(t);"string"==typeof h?n[c]=h+" ":h?x("LispMarkup markup conversion function: template returned value with invalid type."):n[c]=""}else x("LispMarkup: illegal property value type.")}else if("function"==typeof l){var m=l,h=m(t);"string"==typeof h?s.push(h+" "):h?x("LispMarkup markup conversion function: template returned value with invalid type."):s.push("")}else l&&s.push(l.toString()+" ")}if(i){var v=y(i,n);s[0]=v[0],s.push(v[1])}return s.join("")}}}}();var LispMarkupBrowser={};!function(){var p={},s="-container",o="_data",u=/-content$|-template$/,l="text/lisp-markup";return LispMarkupBrowser.setContentTemplate=function(r,e){if(null===e||"undefined"===e)return void delete p[r];"string"==typeof e&&(e=LispMarkup.compileTemplate(e));if("function"!=typeof e)throw new Error("LispMarkupBrowser.setContentTemplate: Template must be a string in LispMarkup format or a function.");p[r]=e},LispMarkupBrowser.getContentTemplate=function(r){return p[r]},LispMarkupBrowser.updateAll=t,LispMarkupBrowser.updateContainers=c,LispMarkupBrowser.getContainers=f,LispMarkup.addMacro("DEFINE",r),LispMarkup.addMacro("DEF",r),window.addEventListener("load",function(){if(console.log("init lisp_markup.js in browser."),!LispMarkup)throw"LispMarkup library not available.";var r=function(){for(var r={},e=document.getElementsByTagName("script"),t=0;t<e.length;++t){var n=e[t],a=n.id,i=n.type,s=n.innerHTML;a&&(a=a.replace(u,"")),i==l&&(r[a]=s)}return r}();for(var e in r)console.log("LispMarkupBrowser: Compiling template: "+e),p[e]=LispMarkup.compileTemplate(r[e]);t()});function r(r,e,t){if(r.length<2)throw new Error("LispMarkupBrowser.macroDefineTemplate: at least 2 list entries required in template definition.");var n=r[1];p.hasOwnProperty(n)&&console.warn("LispMarkupBrowser.macroDefineTemplate: template '"+n+"' already defined.");var a=r.slice(2),i=LispMarkup.compileTemplate(a);p[n]=function(r){return i(r)}}function f(r){for(var e=[],t=r+s,n=document.getElementsByClassName(t),a=0;a<n.length;++a)e.push(n[a]);var i=document.getElementById(t);return i&&e.push(i),e}function t(r){if(null!==r&&null!=r||(r={}),"object"!=typeof r)throw new Error("LispMarkupBrowser.updateAll(): datasets parameter, if specified, must be an object.");for(var e in p)for(var t=f(e),n=0;n<t.length;++n)t[n].innerHTML="";for(var a=[],i={};;)if(0!=a.length){var s=a.shift();c(s,r[s])}else{var o=!1;for(var u in p){0<f(u).length&&(i.hasOwnProperty(u)||(o=!0,a.push(u),i[u]=!0))}if(!o)break}}function c(r,e){var t=f(r);if(0==t.length&&console.warn("LispMarkupBrowser updateContainer(): no container with name '"+r+"'."),void 0===e){var n=r+o;n in window&&(e=window[n])}for(var a=0;a<t.length;++a){var i=p[r];t[a].innerHTML=i(e)}}}();